package com.eeg_project.components.connector;

import android.app.Activity;
import android.os.Handler;
import android.util.Log;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.choosemuse.libmuse.ConnectionState;
import com.choosemuse.libmuse.LibmuseVersion;
import com.choosemuse.libmuse.Muse;
import com.choosemuse.libmuse.MuseConnectionListener;
import com.choosemuse.libmuse.MuseConnectionPacket;
import com.choosemuse.libmuse.MuseListener;
import com.choosemuse.libmuse.MuseManagerAndroid;
import com.choosemuse.libmuse.MuseVersion;
import com.eeg_project.MainApplication;
import com.eeg_project.R;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.uimanager.IllegalViewOperationException;

import java.lang.ref.WeakReference;
import java.util.List;

/**
 * React Native Module which allows LibMuse functions related to searching and connecting Muses
 * to be called from JS
 */

public class ConnectorModule extends ReactContextBaseJavaModule {

    /**
     * Tag used for logging purposes.
     */
    private final String TAG = "EEG 101";

    /**
     The MuseManager is how you detect Muse headbands and receive notifications
     * when the list of available headbands changes.
     */
    private MuseManagerAndroid manager;

    /**
     * The ConnectionListener will be notified whenever there is a change in
     * the connection state of a headband, for example when the headband connects
     * or disconnects.
     *
     * Note that ConnectionListener is an inner class at the bottom of this file
     * that extends MuseConnectionListener.
     */
    private ConnectionListener connectionListener;

    /** Initializes the MainApplication content so that the connectedMuse object stored within it
     * can be referenced.
     * Because this is a ReactContextBaseJavaModule, getCurrentActivity is called first to be able to
     * call getApplication. We may have to be careful with this however, as the React Native documentation advises against holding
     * references to getCurrentActivity return value as member variables
     */
    MainApplication appState = ((MainApplication)this.getCurrentActivity().getApplication());


    public ConnectorModule(ReactApplicationContext reactContext) { super(reactContext); }

    @Override
    public String getName() {
        return "ConnectorModule";
    }

    @ReactMethod
    public void startConnector() {
        // We need to set the context on MuseManagerAndroid before we can do anything.
        // This must come before other LibMuse API calls as it also loads the library.
        manager = MuseManagerAndroid.getInstance();
        manager.setContext(this.getReactApplicationContext());

        Log.i(TAG, "LibMuse version=" + LibmuseVersion.instance().getString());

        // Register a listener to receive connection state changes.
        connectionListener = new ConnectionListener();

        // Register a listener to receive notifications of what Muse headbands
        // we can connect to.
        manager.setMuseListener(new MuseL());

        manager.startListening();
    }

    @ReactMethod
    public void stopConnector() {
        // It is important to call stopListening when the Activity is paused
        // to avoid a resource leak from the LibMuse library.
        manager.stopListening();

        // Unregister listeners from connectMuse
        if (appState.connectedMuse != null) {
            appState.connectedMuse.unregisterAllListeners();
        }
    }

    @ReactMethod
    public void getDevices(Promise promise) {

        // Create WriteableArray that can be passed to JS
        WritableArray availableMuseArray = Arguments.createArray();

        List<Muse> availableMuses = manager.getMuses();

        try {
            // Add the name of each available Muse to an array that will be passed to JS
            for (Muse muse : availableMuses) {
                availableMuseArray.pushString(muse.getName());
            }
            promise.resolve(availableMuseArray);
        } catch (IllegalViewOperationException e) {
            promise.reject(e);
        }
    }

    @ReactMethod
    public void connectDevice(Integer itemIndex) {

        List<Muse> availableMuses = manager.getMuses();

        appState.connectedMuse = availableMuses.get(itemIndex);

        // Unregister all prior listeners and register our data listener to
        // receive the MuseDataPacketTypes we are interested in.  If you do
        // not register a listener for a particular data type, you will not
        // receive data packets of that type.
        appState.connectedMuse.unregisterAllListeners();
        appState.connectedMuse.registerConnectionListener(connectionListener);

        // Initiate a connection to the headband and stream the data asynchronously.
        // runAsynchronously() bridges to a C++ function that is implemented on the Muse
        // Could possibly run this in a different thread, but it requires creating another link
        // to appState.connectedMuse. Feels like a little bit too much.
        try {
            appState.connectedMuse.runAsynchronously();
        } catch (Exception e) {
            Log.w(TAG, "Error thrown in MuseActivity runAsynch");
            e.printStackTrace();
        }
    }

    //--------------------------------------
    // Listeners

    public void museListChanged() {

    }

    /**
     * You will receive a callback to this method each time there is a change to the
     * connection state of one of the headbands.
     * @param p     A packet containing the current and prior connection states
     * @param muse  The headband whose state changed.
     */




    //--------------------------------------
    // Listener translators
    //
    // Each of these classes extend from the appropriate listener and contain a weak reference
    // to the activity.  Each class simply forwards the messages it receives back to the Activity.
    class MuseL extends MuseListener {
        final WeakReference<Activity> activityRef;

        MuseL(final WeakReference<Activity> activityRef) {
            this.activityRef = activityRef;
        }

        @Override
        public void museListChanged() {
            Log.i(TAG, "Muse list changed");
        }
    }

    class ConnectionListener extends MuseConnectionListener {
        final WeakReference<Activity> activityRef;

        ConnectionListener(final WeakReference<Activity> activityRef) {
            this.activityRef = activityRef;
        }

        @Override
        public void receiveMuseConnectionPacket(final MuseConnectionPacket p, final Muse muse) {

            final ConnectionState current = p.getCurrentConnectionState();

            // Format a Toast to show the change of connection state in the UI.
            final String status = "Muse is " + current;
            int duration = Toast.LENGTH_SHORT;
            Toast toast = Toast.makeText(this.getApplicationContext(), status, duration);
            toast.show();


            if (current == ConnectionState.DISCONNECTED) {
                Log.i(TAG, "Muse disconnected:" + muse.getName());
                // We have disconnected from the headband, so set our cached copy to null.
                appState.connectedMuse = null;
            }
        }
    }




}




